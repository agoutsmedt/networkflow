% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_clusters.R
\name{add_clusters}
\alias{add_clusters}
\title{Detect and Add Clusters to Graphs}
\usage{
add_clusters(
  graphs,
  clustering_method = c("leiden", "louvain", "fast_greedy", "infomap", "walktrap"),
  objective_function = c("modularity", "CPM"),
  resolution = 1,
  n_iterations = 1000,
  n_groups = NULL,
  node_weights = NULL,
  trials = 10,
  steps = 4,
  verbose = TRUE
)
}
\arguments{
\item{graphs}{A tibble graph from \href{https://tidygraph.data-imaginist.com/}{tidygraph}, a list of tibble
graphs or a data frame.}

\item{clustering_method}{The different clustering algorithms implemented in the
function (see details). The parameters of the function depend of the clustering method chosen.}

\item{objective_function}{The objective function to maximize for the leiden algorithm.
Whether to use the Constant Potts Model (CPM) or modularity. Must be either "CPM"
or "modularity" (see \code{igraph::cluster_leiden()}). CPM is used by default.}

\item{resolution}{The resolution parameter to use for leiden algorithm
(see \code{igraph::cluster_leiden()}). Higher resolutions lead to more
smaller communities, while lower resolutions lead to fewer larger communities.}

\item{n_iterations}{the number of iterations to iterate the Leiden algorithm.
Each iteration may improve the partition further (see \code{igraph::cluster_leiden()}).}

\item{n_groups}{May be used by the fast greedy or the walktrap algorithm.
Integer scalar, the desired number of communities. If too low or two high,
then an error message is given.}

\item{node_weights}{May be used both for the Leiden or infomap algorithms.
For Leiden, if this is not provided, it will be automatically determined on the
basis of the objective_function (see \code{igraph::cluster_leiden()}). For infomap,
if it is not present, then all vertices are considered to have the same weight.
A larger vertex weight means a larger probability that the random surfer jumps
to that vertex (see \code{igraph::cluster_infomap()}).}

\item{trials}{The number of attempts to partition the network
(can be any integer value equal or larger than 1) for the infomap algorithm
(see \code{igraph::cluster_infomap()}).}

\item{steps}{The length of the random walks to perform for the walktrap algorithm
(see \code{igraph::cluster_walktrap()})}

\item{verbose}{Set to \code{FALSE} if you don't want the function to display different sort of information.}
}
\value{
The same tidygraph graph or tidygraph list as input, but with a new cluster
column for nodes with a column with the size of these clusters,
and three cluster columns for edges (see the details).
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

This function takes as input a tibble graph (from \href{https://tidygraph.data-imaginist.com/}{tidygraph})
or a list of tibble graphs, and then runs different
cluster detection algorithms depending on the method chosen by the user (see @details for
information on the different methods. The function
associate each node to its corresponding cluster identifier. It also creates a cluster
attribute for edges: to each edge is associated a corresponding cluster
identifier if  the two nodes connected by the edge belong to the same
cluster If nodes have a different cluster, the edge takes "00" as cluster attribute.
}
\details{
The function could be run indifferently on one tidigraph object or on a list
of tidygraph object, as created by \code{build_dynamic_networks()}.

The function implements five different algorithms. Four exists in
\href{https://igraph.org/r/}{igraph} and are used in this package through their implement
in \href{https://tidygraph.data-imaginist.com/}{tidygraph} (see
\link[tidygraph:group_graph]{group_graph()}). The function also implements the
Leiden algorithm \insertCite{traag2019}{networkflow} which is in \code{igraph} but not
in \code{tidygraph} yet (see \link[igraph:cluster_leiden]{cluster_leiden()}).

The newly created columns with the cluster identifier for nodes and edges
are named depending of the method used. If you use the Leiden algorithm, the
function will create a column called \code{cluster_leiden} for nodes, and three columns
for the edges, called \code{cluster_leiden_from}, \code{cluster_leiden_to} and \code{cluster_leiden}.

The function also
automatically calculates the percentage of total nodes that are gathered in each
cluster, in the column \code{size_com}.

To make plotting easier later, a zero is put before one-digit cluster identifier
(cluster 5 becomes "05"; cluster 10 becomes "10"). Attributing a cluster identifier to edges
allow for giving edges the same color of the nodes they are connecting together if the two nodes have the same color,
or a different color from both nodes, if the nodes belong to different clusters.
}
\examples{
library(networkflow)

nodes <- Nodes_stagflation |>
dplyr::rename(ID_Art = ItemID_Ref) |>
dplyr::filter(Type == "Stagflation")

references <- Ref_stagflation |>
dplyr::rename(ID_Art = Citing_ItemID_Ref)

temporal_networks <- build_dynamic_networks(nodes = nodes,
directed_edges = references,
source_id = "ID_Art",
target_id = "ItemID_Ref",
time_variable = "Year",
cooccurrence_method = "coupling_similarity",
time_window = 20,
edges_threshold = 1,
overlapping_window = TRUE,
filter_components = TRUE)

temporal_networks <- add_clusters(temporal_networks,
objective_function = "modularity",
clustering_method = "leiden")

temporal_networks[[1]]


}
\references{
\insertAllCited{}
}
